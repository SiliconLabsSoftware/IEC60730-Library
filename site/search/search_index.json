{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Guideline using IEC60730 Safety Library","text":"<p>Platform codes for EFR32 series chips which complies to IEC60730 safety standard</p>"},{"location":"#introduction","title":"Introduction","text":"<p>The IEC60730 library for EFR32 provides a basic implementation required to support the necessary requirements found in Table H.1 in the IEC60730 specification. It includes all the Power On Self Test (POST) functions executed when a device is first powered on, as well as Built In Self Test (BIST) functions that are called periodically to ensure correct operation. Certain portions of the requirements require a detailed understanding of the system under development. Callback functions must be completed by the developer to guarantee meeting the full specification. These include a Safe State function used when validation detects an anomaly, properly implemented communications channels (redundancy, error detection, periodic communications), and Plausibility functions to validate system state (internal variables and inputs/outputs).</p>"},{"location":"#license","title":"License","text":"<p>Please refer License</p>"},{"location":"#release-notes","title":"Release Notes","text":"<p>Please refer document in release_note.md</p>"},{"location":"#iec60730-certificate","title":"IEC60730 Certificate","text":"<p>The Silicon Labs Appliances homepage will contain the final certificate and detailed report when it is completed.</p>"},{"location":"#oem-testing","title":"OEM Testing","text":"<p>Once OEMs have completed integrating their system with the IEC60730 Library, they will need to certify their device with a qualified certification house.</p>"},{"location":"#supported-families","title":"Supported Families","text":"<ul> <li>Refer section Supported Families</li> </ul>"},{"location":"#software-requirements","title":"Software Requirements","text":"<ul> <li>Refer section Software Requirements</li> </ul>"},{"location":"#building-the-iec60730-demo","title":"Building the IEC60730 Demo","text":"<ul> <li>Refer section Building the IEC60730 Demo</li> </ul>"},{"location":"#generate-document-api","title":"Generate document API","text":"<ul> <li>Refer section Generate document API</li> </ul>"},{"location":"#coding-convention-tool","title":"Coding convention tool","text":"<ul> <li>Refer file: coding_convention_tool.md.</li> </ul>"},{"location":"#compiler-specifications","title":"Compiler specifications","text":"<ul> <li>Refer section Compiler specifications</li> </ul>"},{"location":"#system-architecture","title":"System Architecture","text":"<ul> <li>Refer section System Architecture</li> </ul>"},{"location":"#cmake","title":"CMake","text":"<p>The project has a CMake template that supports running tests. Follow the steps below one by one to build and run tests.</p>"},{"location":"#add-the-iec60730-library-extension-to-the-sdk","title":"Add the IEC60730 Library extension to the SDK","text":"<ul> <li>Refer to the IEC60730 safety library integration to SDK in the docs folder for more details.</li> </ul>"},{"location":"#install-dependencies","title":"Install Dependencies","text":""},{"location":"#install-slc-cli","title":"Install slc-cli","text":"<ul> <li>Follow this link to Install slc: Install slc</li> <li>Follow this link to Install Amazon Corretto 17 on Debian-Based Linux</li> </ul>"},{"location":"#how-to-use-slc","title":"How to use slc","text":"<p>Add the path to the expanded slc-cli to your PATH sh export PATH=$PATH:~/SimplicityStudio/slc_cli_linux/slc_cli/</p> <p>Configure SDK. For example sh slc configuration --sdk ~/SimplicityStudio/SDKs/gecko_sdk/</p> <p>Run slc signature trust --sdk  if you have not yet trusted your SDK. <p>For example your SDK locate at ~/SimplicityStudio/SDKs/gecko_sdk/. Run <code>slc signature trust --sdk ~/SimplicityStudio/SDKs/gecko_sdk/</code></p> <p>Set toolchain For example sh slc configuration -gcc=~/SimplicityStudio-5/SimplicityStudio_v5/developer/toolchains/gnu_arm/12.2.rel1_2023.7/</p> <p>Generate the project sh slc generate \\path\\to\\example.slcp -np -d  -name= --with  <p>Choose one of the options below to generate the project</p> Operation Arguments Description generate -cp, --copy-sources Copies all files referenced by this project, selected components, and any other running tools (Pin Tool, etc.). By default, no files are copied. ^ -cpproj, --copy-proj-sources Copies all files referenced by the project and links any SDK sources. This can be combined with -cpsdk. ^ -cpsdk, --copy-sdk-sources Copies all files referenced by the selected components and links any project sources. This can be combined with -cpproj. <p>[!NOTE]: To be able to use the extension LibIEC60730. You need to add the LibIEC60730 extension to your SDK in the extension folder and run the command: <code>slc signature trust -extpath &lt;path_to_your_extension_sdk&gt;</code></p>"},{"location":"#for-example","title":"For example","text":"<pre><code>$ GSDK=~/SimplicityStudio/SDKs/gecko_sdk\n$ slc configuration --sdk=$GSDK --gcc-toolchain=/Applications/ARM\n$ slc generate $GSDK/app/common/example/blink_baremetal -np -d blinky -name=blinky -o makefile\n   --with brd4166a\n$ slc signature trust -extpath $GSDK/extension/IEC60730_Libs\n</code></pre>"},{"location":"#run-unit-test","title":"Run unit test","text":"<ul> <li>Refer to the guideline link: guideline_for_running_unit_test.md</li> </ul>"},{"location":"#run-integration-test","title":"Run integration test","text":"<ul> <li>Refer to the guideline link: guideline_for_running_integration_test.md</li> </ul>"},{"location":"about/","title":"About us","text":"<p>Our web site: www.silabs.com</p>"},{"location":"about/#contact-us","title":"Contact us","text":"<ul> <li> <p>Our community: Community Silabs</p> </li> <li> <p>Our support page: Silicon Labs support page</p> </li> </ul>"},{"location":"about/#special-thanks","title":"Special Thanks","text":"<p>The documentations in this site are created by MkDocs.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>2.0.0 Release</p> <ul> <li> <p>Supported Device: EFR32MG families</p> </li> <li> <p>Supported Compilers: GCC, IAR</p> </li> <li> <p>Update project from make file to CMake file</p> </li> <li> <p>Rewrite the library IEC60730 code</p> </li> <li> <p>Update GSDK extension for the IEC60730 Library following the changes of the source library</p> </li> <li> <p>Support unit test, integration test</p> </li> <li> <p>Support check coding convention</p> </li> <li> <p>Support mkdocs</p> </li> </ul> <p>1.2.0 Release</p> <ul> <li> <p>Supported Devices: EFR32xG24, EFM32xG12</p> </li> <li> <p>Supported Compilers: GCC, IAR</p> </li> <li> <p>Added GSDK extension for the IEC60730 Library.</p> </li> <li> <p>Integrated demo app to the GSDK extension.</p> </li> </ul> <p>1.1.0 Release</p> <ul> <li> <p>Supported IEC60730 standard</p> </li> <li> <p>Supported Devices: EFR32xG22, EFM32PG22</p> </li> <li> <p>Supported Compilers: GCC, IAR</p> </li> </ul> <p>1.0.0 Release</p> <ul> <li> <p>Supported IEC60730 standard</p> </li> <li> <p>Supported Devices: EFR32xG21, EFR32xG23</p> </li> <li> <p>Supported Compilers: GCC, IAR</p> </li> </ul>"},{"location":"coding_convention_tool/","title":"Guideline for running check coding convetion","text":"<p>[!NOTE] This is a code formatter tool that helps ensure consistent coding style and detects common issues in source code files. It integrates with pre-commit, allowing you to automate code formatting and checks as part of your development workflow.</p> <ul> <li>See details rule check in folder tools: tools.</li> </ul>"},{"location":"coding_convention_tool/#features","title":"Features","text":"<ul> <li>Automatically fixes end-of-file issues.</li> <li>Removes trailing whitespace from lines.</li> <li>Identifies and suggests fixes for common spelling errors using codespell.</li> <li>Formats code according to specified Uncrustify rules base on Silabs's coding standard.</li> <li>Checks for identifiers naming style mismatch of function, definition, struct, variable using clang-tidy.</li> <li>Checks code for potential errors and style issues using cppcheck.</li> </ul>"},{"location":"coding_convention_tool/#project-structure","title":"Project Structure","text":"<p>the following outlines the structure of the code formatter project, detailing the purpose of each file and directory.</p> <pre><code>\u251c\u2500\u2500 tools: Contains all config file of codespell, clang-format, clang-tidy.\n|    \u251c\u2500\u2500 codespell\n|    |    \u251c\u2500\u2500 exclude-file.txt: Contains lines to be\n|    |    |      excluded from Codespell checks.\n|    |    \u2514\u2500\u2500 cignore-words.txt: Contains words to be\n|    |          ignored by Codespell to avoid false\n|    |          positives.\n|    |\n|    \u251c\u2500\u2500 uncrustify.cfg: Configuration file for Uncrustify,\n|    |   specifying the coding style and formatting rules.\n|    \u2514\u2500\u2500 .clang-tidy: Configuration file for clang-tidy,\n|         specifying checks and options for static analysis.\n\u2514\u2500\u2500 .pre-commit-config.yaml: Configuration file for\n    pre-commit, defining the hooks and their settings\n    to be run before commits.\n</code></pre>"},{"location":"coding_convention_tool/#installation","title":"Installation","text":""},{"location":"coding_convention_tool/#ubuntu","title":"Ubuntu","text":"<p>Recommended operating system: WSL, Ubuntu 20.04.</p> <p>Ensure Python is installed on your system. Then, install pre-commit clang-format clang-tidy cppcheck by running:</p> <pre><code>$ pip install pre-commit\n$ sudo apt install uncrustify clang-tidy cppcheck\n</code></pre> <p>Recommended version:</p> <ul> <li>Codespell 2.2.4</li> <li>Uncrustify 0.72.0</li> <li>Clang tidy 14.0.0</li> <li>Cppcheck 1.9</li> </ul>"},{"location":"coding_convention_tool/#quick-start","title":"Quick start","text":""},{"location":"coding_convention_tool/#how-to-run","title":"How To Run","text":"<p>Before running the coding convention test, to create a database file for clang-tidy to test, run the command below</p> <p><pre><code>$ make prepare\n$ cd build\n$ cmake --toolchain ../cmake/toolchain.cmake .. -DCHECK_CODING_CONVETION_ENABLE=ON -DBOARD_NAME=brd4187c\n</code></pre> After running the above command, the file <code>compile_commands.json</code> data base will be created in the folder build.</p> <p>Run pre-commit install to install pre-commit into your git hooks. pre-commit will now run on every commit:</p> <pre><code>$ pre-commit install\n</code></pre> <p>Staging files need formatting. For example:</p> <pre><code>$ git add data_format_sample.c\n</code></pre> <p>Run pre-commit hooks on a repository to check coding convention.</p> <pre><code>$ pre-commit run --all-files\n</code></pre>"},{"location":"coding_convention_tool/#exclude-folder","title":"Exclude Folder","text":"<p>When using this tool, you may want to skip some folders.</p> <p>You can specify folders to exclude from formatting and checks by replacing the exclude regex pattern with the folders you want to skip.</p> <p>Here's how you can exclude folders build and gecko_sdk_xxx using regex patterns in .pre-commit-config.yaml file:</p> <pre><code>exclude: .*/build/.*|.*/gecko_sdk.*/.*\n</code></pre> <p>Exclude File, Ignore Words for Codespell When using Codespell, you may encounter false positives or want to exclude specific files or directories from being checked.</p> <p>Codespell provides configuration options to handle these scenarios.</p> <p>Here's an example of a codespell configuration file .codespellrc</p> <pre><code>ignore-words = ./tools/.codespell/ignore-words.txt\nexclude-file = ./tools/.codespell/exclude-file.txt\ncheck-filenames =\ncheck-hidden =\ncount =\nskip = .git,*.a,\n</code></pre> <p>Explanation of Configuration Options</p> <ul> <li>ignore-words : This option points to a file containing words that should be ignored by Codespell. If you encounter a false positive, add the problematic word to ignore-words.txt. Ensure each word is in lowercase and on a new line.</li> <li>exclude-file : This option points to a file containing lines that should be excluded from spell-checking. If a specific line in your code is causing a false positive, copy and paste the entire line into exclude-file.txt.</li> <li>check-filenames: Set this option to true if you want Codespell to check filenames for spelling errors. By default, this is empty (disabled).</li> <li>check-hidden: Set this option to true if you want Codespell to check hidden files for spelling errors. By default, this is empty (disabled).</li> <li>count: Set this option to true if you want Codespell to display the number of occurrences of each misspelled word. By default, this is empty (disabled).</li> <li>skip: This option allows you to specify files or directories that Codespell should skip. You can list multiple entries separated by commas. For example, .git,*.a, will skip the .git directory and all files with the .a extension.</li> </ul>"},{"location":"coding_convention_tool/#uncrustify","title":"Uncrustify","text":"<p>Using automatic source code formatting follows Silabs's coding standard. The Uncrustify configuration file is located at /tools/uncrustify.cfg. Base on the repo /projects/WMN_TOOLS/repos/scripts/browse/uncrustify</p>"},{"location":"coding_convention_tool/#clang-tidy","title":"Clang-Tidy","text":"<ul> <li>Checks for identifiers naming style mismatch</li> <li>Clang-Tidy supports checking casing types (UPPER_CASE/lower_case) and prefixes of</li> <li>Function, Struct, Enum, Global Constant. You can modify the prefix in the file /tools/.clang-tidy.</li> </ul> <p>For example, config function with lower_case and prefix 'sl_'</p> <pre><code>- key: readability-identifier-naming.FunctionCase\n  value: lower_case\n- key: readability-identifier-naming.FunctionPrefix\n  value: 'sl_'\n</code></pre>"},{"location":"coding_convention_tool/#adding-extra-arguments","title":"Adding Extra Arguments","text":"<p>You may need to provide additional paths to header files or define macros for Clang-Tidy to ensure it correctly analyzes your code.</p> <p>This can be done using the --extra-arg option in the hook configuration.</p> <p>To add extra arguments to the clang-tidy hook, modify the args section of the hook configuration in your .pre-commit-config.yaml file.</p> <p>Here's an example of how to add extra arguments:</p> <pre><code>-   repo: https://github.com/pocc/pre-commit-hooks\n    rev: v1.3.5\n    hooks:\n    -   id: clang-tidy\n        args:\n            - --config-file=./tools/.clang-tidy\n            - --use-color\n            - --extra-arg=-I/inc/\n            - --extra-arg=-DMY_MACRO=1\n</code></pre> <p>In this example, we've added two extra arguments to Clang-Tidy:</p> <ul> <li> <p><code>I/inc/</code>: Specifies an include directory where Clang-Tidy will look for header files.</p> </li> <li> <p><code>DMY_MACRO=1</code>: Defines a macro named MY_MACRO with the value 1 for use in the code analysis.</p> </li> </ul>"},{"location":"guideline_for_running_integration_test/","title":"Guideline for running integration test","text":""},{"location":"guideline_for_running_integration_test/#export-variable","title":"Export Variable","text":"<p>[!NOTE] Before running CMake, you need to export some variables first.</p> <p>Export SDK_PATH=, TOOL_DIRS=, TOOL_CHAINS, FLASH_REGIONS_TEST (flash start address support calculate CRC for module invariable memory), JLINK_PATH and path to <code>slc-cli</code> tool a before run config CMake. <p>If you want to calculate from the start address to the end address of Flash:</p> <pre><code>$ export SDK_PATH=~/SimplicityStudio/SDKs/gecko_sdk\n$ export TOOL_DIRS=~/Downloads/SimplicityStudio_v5/developer/toolchains/gnu_arm/12.2.rel1_2023.7/bin\n$ export TOOL_CHAINS=GCC\n$ export JLINK_PATH=/opt/SEGGER/JLink/libjlinkarm.so\n$ export PATH=$PATH:/media/slc_cli/slc_cli_linux_check/slc_cli\n$ export FLASH_REGIONS_TEST=0x8000000\n</code></pre> <p>Or if you want to calculate multiple regions:</p> <pre><code>$ export FLASH_REGIONS_TEST=\"0x8000000 0x8000050 0x80000a0 0x80000f0 0x8000140 0x8000190\"\n</code></pre> <p>with FLASH_REGIONS_TEST=0x8000000 is the flash start address of board name brd4187c (chip EFR32MG24)</p> <p>To run integration tests manually, for the watchdog module, you need to connect the device to ethernet. Export CHIP, ADAPTER_SN, LST_PATH, JLINK_PATH, and the device's IP address and run the test script, for example:</p> <pre><code>$ export CHIP=EFR32MG24BXXXF1536 ADAPTER_SN=440111030\n$ export LST_PATH=~/devs_safety_lib/build/test/integration_test/build/brd4187c/integration_test_iec60730_watchdog/S\n</code></pre> <p>If test secure peripherals or non-secure peripherals:</p> <pre><code>$ export LST_PATH=~/devs_safety_lib/build/test/integration_test/build/brd4187c/integration_test_iec60730_watchdog/NS\n</code></pre> <pre><code>$ export JLINK_PATH=/opt/SEGGER/JLink/libjlinkarm.so\n$ export HOST_IP=192.168.1.69\n</code></pre> <p>[!NOTE] Environment variables need to be exported during test execution:</p> <p>export TOOL_CHAINS= (IAR or GCC)</p> <p>export TOOL_DIRS=  <p>export FLASH_REGIONS_TEST=  <p>export HOST_IP=  <p>export JLINK_PATH="},{"location":"guideline_for_running_integration_test/#build-test-for-iar-tool","title":"Build test for IAR tool","text":"<p>To build tests for the IAR tool, if you run a manual test, you must run the pre-build command below.</p> <pre><code>$ make prepare\n$ cd build\n$ cmake --toolchain ../cmake/toolchain.cmake .. -DPRE_BUILD_IAR_TOOL=ON -DBOARD_NAME=${BOARD_NAME} $OPTION_PRE_BUILD_IAR_TOOL\n$ cd ..\n$ make prepare\n</code></pre> <p>[!NOTE] Keep <code>$OPTION_PRE_BUILD_IAR_TOOL</code> the same when running the integration test CMake config</p> <p>For example, build integration test:</p> <pre><code>$ make prepare\n$ cd build\n$ cmake --toolchain ../cmake/toolchain.cmake .. \u00a0-DPRE_BUILD_IAR_TOOL=ON -DBOARD_NAME=brd4187c -DINTEGRATION_TEST_WDOG1_ENABLE=ON -DINTEGRATION_TEST_USE_MARCHX_DISABLE=ON -DENABLE_CRC_USE_SW=ON -DENABLE_CAL_CRC_32=ON\n$ cd ..\n$ make prepare\n</code></pre> <p>or you can run bash script <code>pre_build_iar.sh</code> in path ./../simplicity_sdk/pre_build_iar.sh with:</p> <ul> <li>$1: BOARD_NAME: brd4187c or EFR32MG24B220F1536IM48</li> <li>$2: OPTION_INTEGRATION_TEST: -DINTEGRATION_TEST_WDOG1_ENABLE=ON, etc...</li> </ul> <pre><code>$ bash pre_build_iar.sh $BOARD_NAME $OPTION_INTEGRATION_TEST\n</code></pre> <p>For example:</p> <pre><code>$ bash pre_build_iar.sh brd4187c \"-DINTEGRATION_TEST_WDOG1_ENABLE=ON\"\n</code></pre> <p>[!NOTE] Do not use option -DENABLE_UNIT_TESTING=ON or -DENABLE_INTEGRATION_TESTING=ON when running pre-build IAR toolchain with option -DPRE_BUILD_IAR_TOOL=ON</p>"},{"location":"guideline_for_running_integration_test/#manually-run-integration-tests","title":"Manually run integration tests","text":"<p>CMake config</p> <pre><code>$ make prepare\n$ cd build\n$ cmake --toolchain ../cmake/toolchain.cmake .. -DENABLE_INTEGRATION_TESTING=ON -DBOARD_NAME=brd4187c\n</code></pre> <p>CMake Build</p> <pre><code>$ cmake --build . --target integration_test_info -j4\n</code></pre> <p>or</p> <pre><code>$ make integration_test_info -j4\n</code></pre> <p>To support running integration tests for the watchdog module, there are 2 options when running the CMake config:</p> <ul> <li> <p>TEST_SECURE_PERIPHERALS_ENABLE: enable test secure peripherals</p> </li> <li> <p>INTEGRATION_TEST_WDOG1_ENABLE: enable watchdog 1 to test if the device supports</p> </li> </ul> <p>To support running integration tests for the variable memory module, there is 1 option when running CMake config:</p> <ul> <li>INTEGRATION_TEST_USE_MARCHX_DISABLE: disable using MarchX algorithm</li> </ul> <p>By default when testing the variable memory module, enable using the MarchX algorithm. For example:</p> <pre><code>$ cmake --toolchain ../cmake/toolchain.cmake .. -DENABLE_INTEGRATION_TESTING=ON -DINTEGRATION_TEST_USE_MARCHX_DISABLE=ON -DBOARD_NAME=brd4187c\n</code></pre> <p>For devices that have a Trust zone implemented, secure and non-secure peripherals need to be tested. Default enable checks non-secure peripherals. To check secure peripherals enable this option when running CMake config: TEST_SECURE_PERIPHERALS_ENABLE. For example:</p> <pre><code>$ cmake --toolchain ../cmake/toolchain.cmake .. -DENABLE_INTEGRATION_TESTING=ON -DTEST_SECURE_PERIPHERALS_ENABLE=ON -DBOARD_NAME=brd4187c\n</code></pre> <p>For devices that support 2 watchdogs, if you want to test both watchdogs, enable option INTEGRATION_TEST_WDOG1_ENABLE to ON when running Cmake config:</p> <pre><code>$ cmake --toolchain ../cmake/toolchain.cmake .. -DENABLE_INTEGRATION_TESTING=ON -DINTEGRATION_TEST_WDOG1_ENABLE=ON -DBOARD_NAME=brd4187c\n</code></pre> <p>To run integration tests for the watchdog module you need to connect the device to ethernet. Export CHIP, ADAPTER_SN, LST_PATH, JLINK_PATH, and the device's IP address and run the test script, for example:</p> <pre><code>$ export CHIP=EFR32MG24BXXXF1536 ADAPTER_SN=440111030\n$ export LST_PATH=~/devs_safety_lib/build/test/integration_test/build/brd4187c/integration_test_iec60730_watchdog/S\n</code></pre> <p>If test secure peripherals or non-secure peripherals:</p> <pre><code>$ export LST_PATH=~/devs_safety_lib/build/test/integration_test/build/brd4187c/integration_test_iec60730_watchdog/NS\n</code></pre> <pre><code>$ export JLINK_PATH=/opt/SEGGER/JLink/libjlinkarm.so\n$ export HOST_IP=192.168.1.69\n</code></pre> <pre><code>$ python3 integration_test_iec60730_irq.py GCC\n</code></pre> <p>By default, the device enables watchdog 0 and test watchdog 0. If you want to test Watchdog 1 use this command:</p> <pre><code>$ INTEGRATION_TEST_WDOG1_ENABLE=enable python3 integration_test_iec60730_watchdog.py GCC\n</code></pre> <p>If you want to test the variable memory module with disable using the MarchX algorithm:</p> <pre><code>$ INTEGRATION_TEST_USE_MARCHX_DISABLE=disable python3 integration_test_iec60730_variable_memory.py GCC\n</code></pre> <p>If you want to test the invariable memory module with calculate crc32:</p> <pre><code>$ INTEGRATION_TEST_ENABLE_CAL_CRC_32=enable python3 integration_test_iec60730_variable_memory.py GCC\n</code></pre>"},{"location":"guideline_for_running_integration_test/#automatically-run-integration-tests","title":"Automatically run integration tests","text":"<p>Command run</p> <pre><code>bash execute_test.sh $1 $2 $3 $4 $5 $6\n</code></pre> <p>With the input arguments, there is the following information.</p> <ul> <li>$1: BOARD_NAME: brd4187c or EFR32MG24B220F1536IM48</li> <li>$2: task: all, gen-only, run-only</li> <li>$3: components: all, unit_test_iec60730_bist, unit_test_iec60730_post, ...</li> <li>$4: ADAPTER_SN</li> <li>$5: compiler: GCC, IAR</li> <li>$6: OPTION_SUPPORT_INTEGRATION_TEST: \"-DENABLE_CAL_CRC_32=ON -DENABLE_CRC_USE_SW=ON -DTEST_SECURE_PERIPHERALS_ENABLE=ON -DINTEGRATION_TEST_WDOG1_ENABLE=ON - INTEGRATION_TEST_USE_MARCHX_DISABLE=ON\"</li> </ul> <p>Which, components list that support testing includes:</p> <ul> <li> <p>integration_test_iec60730_program_counter</p> </li> <li> <p>integration_test_iec60730_irq</p> </li> <li> <p>integration_test_iec60730_system_clock</p> </li> <li> <p>integration_test_iec60730_watchdog</p> </li> <li> <p>integration_test_iec60730_cpu_registers</p> </li> <li> <p>integration_test_iec60730_variable_memory</p> </li> <li> <p>integration_test_iec60730_invariable_memory</p> </li> </ul> <p>Before running the bash file, you need to install Jlink, Srecord, and slc tool, refer Overview to set up some environment variables as follows: If the compiler is GCC - If the compiler is GCC:</p> <p>If you want to calculate from the start address to the end address of Flash:</p> <pre><code>$ export SDK_PATH=~/SimplicityStudio/SDKs/gecko_sdk\n$ export TOOL_DIRS=~/Downloads/SimplicityStudio_v5/developer/toolchains/gnu_arm/12.2.rel1_2023.7/bin\n$ export TOOL_CHAINS=GCC\n$ export FLASH_REGIONS_TEST=0x8000000\n$ export JLINK_PATH=/opt/SEGGER/JLink/libjlinkarm.so\n$ export HOST_IP=192.168.1.69\n</code></pre> <p>Or if you want to calculate multiple regions:</p> <pre><code>$ export FLASH_REGIONS_TEST=\"0x8000000 0x8000050 0x80000a0 0x80000f0 0x8000140 0x8000190\"\n</code></pre> <p>[!NOTE] In the current integration test file, only enable computation of one region: from the start address of \u200b\u200bthe flash to the end of the flash. Therefore, export the flash's starting address. For example, chip EFR32MG24:</p> <p>$ export FLASH_REGIONS_TEST=0x8000000</p>"},{"location":"guideline_for_running_integration_test/#example","title":"Example","text":"<ul> <li>With GCC toolchain:</li> </ul> <pre><code>bash execute_integration_test.sh brd4187c all all 440111030 GCC\n</code></pre> <ul> <li>With IAR toolchain:</li> </ul> <pre><code>bash execute_integration_test.sh brd4187c all all 440111030 IAR\n</code></pre>"},{"location":"guideline_for_running_integration_test/#note","title":"Note:","text":"<p>In case you want to build CRC32 run this command. For example:</p> <pre><code>bash execute_integration_test.sh brd4187c all all 440111030 GCC \"-DENABLE_CAL_CRC_32=ON\"\n</code></pre> <p>Or case you want to use the above integration test support options, run this command. For example:</p> <pre><code>bash execute_integration_test.sh brd4187c all all 440111030 GCC \"-DTEST_SECURE_PERIPHERALS_ENABLE=ON -DINTEGRATION_TEST_WDOG1_ENABLE=ON -DINTEGRATION_TEST_USE_MARCHX_DISABLE=ON -DENABLE_CAL_CRC_32=ON\"\n</code></pre>"},{"location":"guideline_for_running_integration_test/#crc-calculation-options","title":"CRC calculation options","text":"<p>When running build CMake to run unit tests and integration tests for invariable memory modules, the CRC calculation image file will have the suffix _crc16 or _crc32, you must flash the image file with this suffix.</p> <p>With the commands above, the default value supports the calculation CRC-16. If you want to change to calculate for CRC-32 bits, use the CMake config command below:</p> <ul> <li>With integration test:</li> </ul> <p>by manually</p> <pre><code>$ cmake --toolchain ../cmake/toolchain.cmake .. -DENABLE_INTEGRATION_TESTING=ON -DBOARD_NAME=brd4187c -DENABLE_CAL_CRC_32=ON\n</code></pre> <p>or by automatically</p> <pre><code>bash execute_integration_test.sh brd4187c all all 440111030 GCC \"-DENABLE_CAL_CRC_32=ON\"\n</code></pre> <p>Here are some options to support running tests of invariable memory modules:</p> <ul> <li> <p>ENABLE_CAL_CRC_32</p> </li> <li> <p>ENABLE_CRC_USE_SW (if this option is ON, you can enable option: ENABLE_SW_CRC_TABLE for using the pre-defined table for calculating or not)</p> </li> </ul> <p>[!NOTE] Only use the ENABLE_SW_CRC_TABLE option when the ENABLE_CRC_USE_SW option is ON, otherwise, an error will be reported during the build process.</p>"},{"location":"guideline_for_running_unit_test/","title":"Guideline for running unit test","text":""},{"location":"guideline_for_running_unit_test/#export-variable","title":"Export Variable","text":"<p>[!NOTE] Before running CMake, you need to export some variables first.</p> <p>Export SDK_PATH=, TOOL_DIRS=, TOOL_CHAINS, FLASH_REGIONS_TEST (flash start address support calculate CRC for module invariable memory), JLINK_PATH and path to <code>slc-cli</code> tool a before run config CMake. <p>If you want to calculate from the start address to the end address of Flash:</p> <pre><code>$ export SDK_PATH=~/SimplicityStudio/SDKs/gecko_sdk\n$ export TOOL_DIRS=~/Downloads/SimplicityStudio_v5/developer/toolchains/gnu_arm/12.2.rel1_2023.7/bin\n$ export TOOL_CHAINS=GCC\n$ export JLINK_PATH=/opt/SEGGER/JLink/libjlinkarm.so\n$ export PATH=$PATH:/media/slc_cli/slc_cli_linux_check/slc_cli\n$ export FLASH_REGIONS_TEST=0x8000000\n</code></pre> <p>Or if you want to calculate multiple regions:</p> <pre><code>$ export FLASH_REGIONS_TEST=\"0x8000000 0x8000050 0x80000a0 0x80000f0 0x8000140 0x8000190\"\n</code></pre> <p>with FLASH_REGIONS_TEST=0x8000000 is the flash start address of board name brd4187c (chip EFR32MG24)</p>"},{"location":"guideline_for_running_unit_test/#build-test-for-iar-tool","title":"Build test for IAR tool","text":"<p>To build tests for the IAR tool, if you run a manual test, you must run the pre-build command below.</p> <pre><code>$ make prepare\n$ cd build\n$ cmake --toolchain ../cmake/toolchain.cmake .. -DPRE_BUILD_IAR_TOOL=ON -DBOARD_NAME=${BOARD_NAME} $OPTION_PRE_BUILD_IAR_TOOL\n$ cd ..\n$ make prepare\n</code></pre> <p>[!NOTE] Keep <code>$OPTION_PRE_BUILD_IAR_TOOL</code> the same when running unit test CMake config</p> <p>For example, build unit test:</p> <pre><code>$ make prepare\n$ cd build\n$ cmake --toolchain ../cmake/toolchain.cmake .. -DPRE_BUILD_IAR_TOOL=ON -DBOARD_NAME=brd4187c -DENABLE_CRC_USE_SW=ON -DENABLE_CAL_CRC_32=ON\n$ cd ..\n$ make prepare\n</code></pre> <p>or you can run bash script <code>pre_build_iar.sh</code> in path ./../simplicity_sdk/pre_build_iar.sh with:</p> <ul> <li>$1: BOARD_NAME: brd4187c or EFR32MG24B220F1536IM48</li> <li>$2: OPTION_UNIT_TEST: -DENABLE_CRC_USE_SW=ON , etc...</li> </ul> <pre><code>$ bash pre_build_iar.sh $BOARD_NAME $OPTION_UNIT_TEST\n</code></pre> <p>For example:</p> <pre><code>$ bash pre_build_iar.sh brd4187c \"-DENABLE_CRC_USE_SW=ON\"\n</code></pre> <p>[!NOTE] Do not use option -DENABLE_UNIT_TESTING=ON or -DENABLE_INTEGRATION_TESTING=ON when running pre-build IAR toolchain with option -DPRE_BUILD_IAR_TOOL=ON</p>"},{"location":"guideline_for_running_unit_test/#manually-run-unit-tests","title":"Manually run unit tests","text":"<p>CMake config</p> <pre><code>$ make prepare\n$ cd build\n$ cmake --toolchain ../cmake/toolchain.cmake .. -DENABLE_UNIT_TESTING=ON -DBOARD_NAME=brd4187c\n</code></pre> <p>CMake Build</p> <pre><code>$ cmake --build . --target unit_test_info -j4\n</code></pre> <p>or</p> <pre><code>$ make unit_test_info -j4\n</code></pre>"},{"location":"guideline_for_running_unit_test/#automatically-run-unit-tests","title":"Automatically run unit tests","text":"<p>Command run</p> <pre><code>bash execute_test.sh $1 $2 $3 $4 $5 $6\n</code></pre> <p>With the input arguments, there is the following information.</p> <ul> <li>$1: BOARD_NAME: brd4187c or EFR32MG24B220F1536IM48</li> <li>$2: task: all, gen-only, run-only</li> <li>$3: components: all, unit_test_iec60730_bist, unit_test_iec60730_post, ...</li> <li>$4: ADAPTER_SN</li> <li>$5: compiler: GCC, IAR</li> <li>$6: OPTION_SUPPORT_UNIT_TEST: \"-DENABLE_CAL_CRC_32=ON -DENABLE_CRC_USE_SW\"</li> </ul> <p>Which, components list that supports unit testing includes:</p> <ul> <li> <p>unit_test_iec60730_post</p> </li> <li> <p>unit_test_iec60730_bist</p> </li> <li> <p>unit_test_iec60730_program_counter</p> </li> <li> <p>unit_test_iec60730_safety_check</p> </li> <li> <p>unit_test_iec60730_irq</p> </li> <li> <p>unit_test_iec60730_system_clock</p> </li> <li> <p>unit_test_iec60730_watchdog</p> </li> <li> <p>unit_test_iec60730_cpu_registers</p> </li> <li> <p>unit_test_iec60730_variable_memory</p> </li> <li> <p>unit_test_iec60730_invariable_memory</p> </li> </ul> <p>Before running the bash file, you need to install Jlink, Srecord, and slc tool, refer Overview to set up some environment variables as follows: If the compiler is GCC - If the compiler is GCC:</p> <p>If you want to calculate from the start address to the end address of Flash:</p> <pre><code>$ export SDK_PATH=~/SimplicityStudio/SDKs/gecko_sdk\n$ export TOOL_DIRS=~/Downloads/SimplicityStudio_v5/developer/toolchains/gnu_arm/12.2.rel1_2023.7/bin\n$ export TOOL_CHAINS=GCC\n$ export FLASH_REGIONS_TEST=0x8000000\n$ export JLINK_PATH=/opt/SEGGER/JLink/libjlinkarm.so\n</code></pre> <p>Or if you want to calculate multiple regions:</p> <pre><code>$ export FLASH_REGIONS_TEST=\"0x8000000 0x8000050 0x80000a0 0x80000f0 0x8000140 0x8000190\"\n</code></pre> <p>[!NOTE] In the current unit test file, only enable computation in one region: from the start address of \u200b\u200bthe flash to the end of the flash. Therefore, just export the flash's starting address. For example, chip EFR32MG24:</p> <p>$ export FLASH_REGIONS_TEST=0x8000000</p>"},{"location":"guideline_for_running_unit_test/#example","title":"Example","text":"<ul> <li>With GCC toolchain:</li> </ul> <pre><code>bash execute_unit_test.sh brd4187c all all 440111030 GCC\n</code></pre> <ul> <li>With IAR toolchain:</li> </ul> <pre><code>bash execute_unit_test.sh brd4187c all all 440111030 IAR\n</code></pre>"},{"location":"guideline_for_running_unit_test/#crc-calculation-options","title":"CRC calculation options","text":"<p>When running build CMake to run unit tests and integration tests for invariable memory modules, the CRC calculation image file will have the suffix _crc16 or _crc32, you must flash the image file with this suffix.</p> <p>With the commands above, the default value supports the calculation CRC-16. If you want to change to calculate for CRC-32 bits, use the CMake config command below:</p> <ul> <li>With unit test:</li> </ul> <p>by manually</p> <pre><code>$ cmake --toolchain ../cmake/toolchain.cmake .. -DENABLE_UNIT_TESTING=ON -DBOARD_NAME=brd4187c -DENABLE_CAL_CRC_32=ON\n</code></pre> <p>or by automatically</p> <pre><code>bash execute_unit_test.sh brd4187c all all 440111030 GCC \"-DENABLE_CAL_CRC_32=ON\"\n</code></pre> <p>Here are some options to support running tests of invariable memory modules:</p> <ul> <li> <p>ENABLE_CAL_CRC_32</p> </li> <li> <p>ENABLE_CRC_USE_SW (if this option is ON, you can enable option: ENABLE_SW_CRC_TABLE for using the pre-defined table for calculating or not)</p> </li> </ul> <p>[!NOTE] Only use the ENABLE_SW_CRC_TABLE option when the ENABLE_CRC_USE_SW option is ON, otherwise, an error will be reported during the build process.</p>"},{"location":"iec60730_safety_library_integration_to_sdk/","title":"User Guide: The Library IEC60730 Integration","text":"<p>This document provides instructions for integrating the Library IEC60730 into a project.</p> <p>This will guide the developer to install the required software. Then guide the configuration of a project and integrate the source code into the project.</p> <p></p> <p></p> <p>SILICON LABS</p>"},{"location":"iec60730_safety_library_integration_to_sdk/#contents","title":"Contents","text":"<p>Contents</p> <p>Table of pictures</p> <p>1. Background</p> <p>2. Install the required software</p> <p>3. Add an extension to Simplicity Studio</p> <p>4. Generate an example project</p> <p>5. Edit the Linker file</p> <p>6. Edit the post-build steps</p> <p>7. Edit the included path and preprocessor</p> <p>8. Add the source code to the project</p> <p>9. Integrate code into the project</p> <p>10. Revision history</p>"},{"location":"iec60730_safety_library_integration_to_sdk/#table-of-pictures","title":"Table of pictures","text":"<p>Figure 1 Adding Extension to SDK</p> <p>Figure 2 Browse to extension location</p> <p>Figure 3 Create new project</p> <p>Figure 4 Target, SDK, and Toolchain Selection</p> <p>Figure 5 Add toolchains</p> <p>Figure 6 IAR toolchain</p> <p>Figure 7 Example Project Selection</p> <p>Figure 8 Project Configuration</p> <p>Figure 9 Project generation in workspace</p> <p>Figure 10 Build Project</p> <p>Figure 11 Edit the Linker Script Path</p> <p>Figure 12 CRC-16 and CRC-32 script</p> <p>Figure 13 Add the Command to Post-build steps</p> <p>Figure 14 Result after Post-build complete</p> <p>Figure 15 Add the included path and preprocessor</p> <p>Figure 16 Components support library IEC60730</p> <p>Figure 17 Add source code library IEC60730</p> <p>Figure 18 Assembly code algorithm MARCHC for GCC compiler</p> <p>Figure 19 Flow chart of the library IEC60730</p> <p>Figure 20 Demo OEM files integrated with Library IEC60730</p> <p>Figure 21 IAR define check_sum variable</p> <p>Figure 22 Configuration for watchdog module</p> <p>Figure 23 Configuration for system clock module</p>"},{"location":"iec60730_safety_library_integration_to_sdk/#1-background","title":"1. Background","text":"<p>The IEC60730 is a safety standard used in household applications. It defines the test and diagnostic method that ensures the safe operation of devices. We provide the test of the following components: CPU registers, variable memory check, invariable memory check, program counter check, clock check, and interrupt check.</p> <p>At the time of this writing, the library IEC60730 has been tested on two devices EFR32xG12, and EFR32xG24 on Simplicity Studio 5 (SS5)with toolchain GNU ARM v12.2.1 and SDK version 4.4.2.</p>"},{"location":"iec60730_safety_library_integration_to_sdk/#2-install-the-required-software","title":"2. Install the required software.","text":"<p>We use the third-party software SRecord to calculate CRC value. Firstly, you need to install this software. If you're using Windows OS, you can go to the link of this software (link above), download the installation, and run the installer to install. If you're using Ubuntu OS, please follow the installation instructions below.</p> <pre><code>$ sudo apt update\n$ sudo apt install srecord\n</code></pre>"},{"location":"iec60730_safety_library_integration_to_sdk/#3-add-an-extension-to-simplicity-studio","title":"3. Add an extension to Simplicity Studio","text":"<p>The safety library IEC60730 is supported by adding the IEC60730 extension, which is built using the software environment.:</p> <ul> <li> <p>OS-Ubuntu 20.04</p> </li> <li> <p>Simplicity Studio 5</p> </li> <li> <p>Gecko SDK Suite v4.4.2</p> </li> </ul> <p>This project is organized as an extension of Simplicity Studio. This project is built upon GSDK version 4.4.2, GNU toolchain V12.2.1. The user can download the same version of GSDK from GitHub GSDK and Simplicity Studio V5 download link Simplicity Studio V5.</p> <p>To create and build demo projects, the user must add the IEC60730 extension to Simplicity Studio. The procedure would be <code>Window &gt; Preferences &gt; Simplicity Studio &gt;  SDKs &gt; Gecko SDK Suite v4.4.2 &gt; Add Extension</code>.</p> <p></p>"},{"location":"iec60730_safety_library_integration_to_sdk/#figure-1-adding-extension-to-sdk","title":"Figure 1 Adding Extension to SDK","text":"<p>Press <code>Browse</code> to find the directory of this extension. Then choose the folder that has the file name <code>iec60730.slce</code>. Simplicity Studio will detect SDK extensions automatically. Click <code>OK</code> then <code>Apply and Close</code></p> <p></p>"},{"location":"iec60730_safety_library_integration_to_sdk/#figure-2-browse-to-extension-location","title":"Figure 2 Browse to extension location","text":""},{"location":"iec60730_safety_library_integration_to_sdk/#4-generate-an-example-project","title":"4. Generate an example project.","text":"<p>Before using Simplicity Studio to generate the project, you need to add the IEC60730 extension. Please remember the following text:</p> <p><code>\"This extension supports a demo example for EFR32MG families\"</code></p> <p>Start a Project. Select <code>Files &gt; New &gt; Project</code> to open the New Project Wizards dialog. Choose <code>Silicon Labs Project Wizard &gt; Finish</code>.</p> <p></p>"},{"location":"iec60730_safety_library_integration_to_sdk/#figure-3-create-new-project","title":"Figure 3 Create new project","text":"<p>To create a new Simplicity Studio\u00ae 5 (SSv5) project, follow these three dialog steps:</p> <ul> <li> <p>Target, SDK, and Toolchain</p> </li> <li> <p>Examples</p> </li> <li> <p>Configuration</p> </li> </ul> <p>An indicator at the top of the dialog will show you your current position in the process. You can click <code>Back</code> at any time to return to a previous dialog if you need to make changes.</p> <p>For the radio board, in the <code>Target, SDK, and Toolchain Selection</code> dialog, if you have connected to or selected a target, all relevant information will be pre-populated. If no target is selected, you can choose the target parts here. For example, you can select <code>EFR32MG12 2.4GHz 10 dBm Radio Board (Rev A02)</code> in the Target Boards section, with the Target Device set to <code>EFR32MG12P332F1024GL125</code> as shown in the image below.</p> <p></p>"},{"location":"iec60730_safety_library_integration_to_sdk/#figure-4-target-sdk-and-toolchain-selection","title":"Figure 4 Target, SDK, and Toolchain Selection","text":"<p>Next, choose the SDK you installed, such as <code>Gecko SDK v4.4.2</code>. For the <code>IDE/Toolchain</code> select the toolchain version, such as <code>GNU ARM v12.2.1.</code> Finally, click <code>NEXT</code>.</p> <p>If you have installed the IAR toolchain and want to use it to build the demo project. For adding the IAR toolchain in Simplicity Studio: <code>Preferences &gt; Toolchains &gt; Add &gt; Browse go to the folder containing the toolchain then click OK &gt; Apply and Close</code></p> <p></p>"},{"location":"iec60730_safety_library_integration_to_sdk/#figure-5-add-toolchains","title":"Figure 5 Add toolchains","text":"<p>After you add your IAR toolchains, in the selection <code>IDE/Toolchain</code> choose toolchain <code>IAR ARM vn.n.n.n</code>. For example,Simplicity <code>IDE/IAR ARM v9.20.4.327</code>.</p> <p></p>"},{"location":"iec60730_safety_library_integration_to_sdk/#figure-6-iar-toolchain","title":"Figure 6 IAR toolchain","text":"<p>In <code>Example Project Selection</code>, use the checkboxes or keywords to find the example of interest. To create a radio board example IEC60730 Demo, search the keyword <code>iec60730</code> in the search box, related examples will show. Choose <code>IEC60730 Example Demo</code>. Click <code>NEXT</code></p> <p></p>"},{"location":"iec60730_safety_library_integration_to_sdk/#figure-7-example-project-selection","title":"Figure 7 Example Project Selection","text":"<p>In <code>Project Configuration Selection</code>, rename and location your project if you want. For the three selections under <code>With project files</code>, you can choose any of the selections you want.</p> <p></p>"},{"location":"iec60730_safety_library_integration_to_sdk/#figure-8-project-configuration","title":"Figure 8 Project Configuration","text":"<p>Once you finish project creation, the Simplicity IDE perspective opens. There may be a slight delay in the initial configuration.</p> <p>The project typically opens <code>README tab</code>, which contains an example project description, and <code>OVERVIEW tab</code>.</p> <p></p>"},{"location":"iec60730_safety_library_integration_to_sdk/#figure-9-project-generation-in-workspace","title":"Figure 9 Project generation in workspace","text":"<p>For the building project, choose the project you want to build and click on the icon hammer to build, or click the right mouse and choose <code>Build Project</code>.</p> <p></p>"},{"location":"iec60730_safety_library_integration_to_sdk/#figure-10-build-project","title":"Figure 10 Build Project","text":""},{"location":"iec60730_safety_library_integration_to_sdk/#5-edit-the-linker-file","title":"5. Edit the Linker file.","text":"<p>We will base on the example extension project above and edit this project to a new linker file that meets the requirements of the library IEC60730.</p> <p>Some points for editing the linker file are described in IEC 60730's document. You can refer to the modified linker file in our demo example by checking sections 3 and 4 to create our demo. In our demo, the path to the linker file is automated and set to our linker. You should copy the linker file to another location on your PC and start editing it.</p> <p>After editing the linker file, you need to edit the path pointing to this new linker file. Figure 11 Edit the Linker Script Path shows how to edit the Linker Script Path in Simplicity Studio.</p> <p>You SHOULD follow these steps: <code>C/C++Build &gt; Settings &gt; Tool Settings &gt; Memory Layout &gt; Browse</code>.</p> <p></p>"},{"location":"iec60730_safety_library_integration_to_sdk/#figure-11-edit-the-linker-script-path","title":"Figure 11 Edit the Linker Script Path","text":""},{"location":"iec60730_safety_library_integration_to_sdk/#6-edit-the-post-build-steps","title":"6. Edit the post-build steps.","text":"<p>By default, after building the project, files in <code>*.bin</code>, <code>*.hex</code>, and <code>*.s37</code> formats will be created. If you want to create another format, you SHOULD follow these steps: <code>C/C++Build \u00a0&gt; \u00a0Settings \u00a0&gt; \u00a0Build Steps \u00a0&gt; Post-build steps &gt; Command</code>.</p> <p>In this context, we need to modify the command in the <code>Post-build</code> steps to generate new firmware files with a CRC value appended at the end of the FLASH area. Currently, we support two scripts that calculate CRC16 and CRC32, which can be executed on PCs running Windows or Ubuntu OS. You can find these scripts in the <code>lib/crc</code> folder.</p> <p></p>"},{"location":"iec60730_safety_library_integration_to_sdk/#figure-12-crc-16-and-crc-32-scripts","title":"Figure 12 CRC-16 and CRC-32 scripts","text":"<p>The scripts have suffixes of <code>_crc16</code> and <code>_crc32</code> respectively. We will use the suffix <code>_crcNN</code> for both cases.</p> <p>Detailed parameters of the <code>sl_iec60730_cal_crcNN</code> script can refer to can refer to the document Support calculate CRC. In our example, two script files supporting CRC-16 and CRC-32 are automatically copied into the project. For a demo example, you can use this command below to calculate the CRC value for file build <code>*.bin</code>, <code>*.hex</code>, and <code>*.s37</code> and file <code>*.lst</code> with GCC toolchain :</p> <pre><code>$ arm-none-eabi-objdump -t -h -d -S '${BuildArtifactFileBaseName}.axf' &gt;'${BuildArtifactFileBaseName}.lst' &amp;&amp; bash ${ProjDirPath}/iec60730_1.1.0/lib/crc/sl_iec60730_cal_crc16.sh ${BuildArtifactFileBaseName} \"\" \"C:\\srecord\\bin\" GCC \"0x8000000\"\n</code></pre> <p></p>"},{"location":"iec60730_safety_library_integration_to_sdk/#figure-13-add-the-command-to-post-build-steps","title":"Figure 13 Add the Command to Post-build steps","text":"<p>Or with IAR toolchains:</p> <pre><code>ielfdumparm --all --source ${BuildArtifactFileBaseName}.out &gt; ${BuildArtifactFileBaseName}.lst &amp;&amp; bash ${ProjDirPath}/iec60730_1.1.0/lib/crc/sl_iec60730_cal_crc16.sh ${BuildArtifactFileBaseName} \"\" \"C:\\srecord\\bin\" IAR \"0x8000000\"\n</code></pre> <p>[!NOTE] In the default configuration, <code>SL_IEC60730_CRC_DEBUG_ENABLE</code> support debugging the CRC test module invariable memory calculations on demo project is enabled. If you want to disable this configuration, you should copy either <code>sl_iec60730_cal_crc32.sh</code> or <code>sl_iec60730_cal_crc16.sh</code> in the path: <code>lib/crc/</code> which helps a CRC-calculated image file for testing. You must flash the image with the corresponding image file suffixes _crc16 and _crc32.</p> <p>If, during the project configuration step, you choose an option in the <code>With Project File</code> section either <code>Link to SDK and Copy Project Structures</code> or <code>Link to Source</code>, you will need to copy <code>sl_iec60730_cal_crc32.sh</code> or <code>sl_iec60730_cal_crc16.sh</code> to <code>lib/crc</code> folder of your current project directory.</p> <p>After the build of a project is complete, it will call the command in the Post-build steps to create _crc16 or _crc32 files with the extension <code>*.bin</code>, <code>*.hex</code>, and <code>*.s37</code>. <p></p>"},{"location":"iec60730_safety_library_integration_to_sdk/#figure-14-result-after-post-build-complete","title":"Figure 14 Result after Post-build complete","text":""},{"location":"iec60730_safety_library_integration_to_sdk/#7-edit-the-included-path-and-preprocessor","title":"7. Edit the included path and preprocessor.","text":"<p>Edit the Include paths (-l) to the location of the source code of the Library IEC60730.</p> <p>You <code>SHOULD</code> follow these steps: <code>C/C++Build &gt; Settings &gt; Tool Settings &gt; GNU ARM C Compiler</code> choose <code>Include</code> or <code>Preprocessor</code> for include header files and add definitions to your project.</p> <p></p>"},{"location":"iec60730_safety_library_integration_to_sdk/#figure-15-add-the-included-path-and-preprocessor","title":"Figure 15 Add the included path and preprocessor","text":"<p>Edit preprocessor, the user needs definitions as below.</p> <ul> <li>SL_IEC60730_BOARD_HEADER=\"sl_iec60730_board.h\"</li> </ul> <p>By default, the demo example has the definitions above. You can refer to our demo example of these settings.</p>"},{"location":"iec60730_safety_library_integration_to_sdk/#8-add-the-source-code-to-the-project","title":"8. Add the source code to the project.","text":"<p>In our example, after adding the SDK extension, the software component will have a few components that support adding code files (*.c, *. s) of Library IEC60730 to the project:</p> <p></p>"},{"location":"iec60730_safety_library_integration_to_sdk/#figure-16-components-support-library-iec60730","title":"Figure 16 Components support library IEC60730","text":"<p>When you install these components, the source code library IEC60730 will be added. For example:</p> <p></p>"},{"location":"iec60730_safety_library_integration_to_sdk/#figure-17-add-source-code-library-iec60730","title":"Figure 17 Add source code library IEC60730","text":"<p>Component <code>IEC60730 VMC MarchC</code>(see Figure 16) support for adding assembly code algorithm <code>MarchC</code> and <code>MarchXC</code>. If you use the IAR compiler, this component will add to assembly files <code>sl_iec60730_vmc_marchc_iar.S</code> and <code>sl_iec60730_vmc_marchxc_iar.S</code>. If you use the GCC compiler, this component will add <code>sl_iec60730_vmc_marchc.S</code> and <code>sl_iec60730_vmc_marchxc.S</code> for the test VMC module.</p> <p></p>"},{"location":"iec60730_safety_library_integration_to_sdk/#figure-18-assembly-code-algorithm-marchc-for-gcc-compiler","title":"Figure 18 Assembly code algorithm MARCHC for GCC compiler","text":""},{"location":"iec60730_safety_library_integration_to_sdk/#9-integrate-code-into-the-project","title":"9. Integrate code into the project.","text":"<p>The library IEC60730 has been divided into 2 main test phases: Power on Self-Test (POST) and Build In Self-Test (BIST). Figure 19 Flow chart of the library IEC60730 shows the basics of the library IEC60730 integration into a user software solution.</p> <p></p>"},{"location":"iec60730_safety_library_integration_to_sdk/#figure-19-flow-chart-of-the-library-iec60730","title":"Figure 19 Flow chart of the library IEC60730","text":"<p>In our example, we have added a demo <code>oem</code> foler  (Original equipment manufacturer) to integrate with the library IEC60730 to test steps such as flow charts fully.</p> <p></p>"},{"location":"iec60730_safety_library_integration_to_sdk/#figure-20-demo-oem-files-integrated-with-library-iec60730","title":"Figure 20 Demo OEM files integrated with Library IEC60730","text":"<p>If you want to add your OEM code and don't want to use our OEM files demo, you COULD add your OEM code via the following steps below:</p>"},{"location":"iec60730_safety_library_integration_to_sdk/#1-requires-declaration-and-initialize-variables-for-iec60730-library-with-constant-values-refer-function-oem_iec60730_init-in-file-oem_iec60730c","title":"1. Requires declaration and initialize variables for IEC60730 library with constant values. Refer function <code>oem_iec60730_init</code> in file <code>oem_iec60730.c</code>.","text":"<pre><code>sl_iec60730_vmc_test_multiple_regions_t oem_vmc_test;\nsl_iec60730_imc_test_multiple_regions_t oem_imc_test __CLASSB_RAM;\nsl_iec60730_irq_cfg_t oem_irq_config;\n</code></pre> <p>These three variables are used for interrupt, invariable memory check and variable memory check.</p>"},{"location":"iec60730_safety_library_integration_to_sdk/#2-to-perform-an-invariable-memory-check-the-library-uses-crc-cyclic-redundancy-check-calculations-for-flash-memory-if-the-user-calculates-using-hardware-the-user-will-need-to-initialize-the-gpcrc-module-to-support-the-calculation-users-can-also-enable-define-sl_iec60730_crc_use_sw_enable-for-software-calculation-to-calculate-the-crc-value-it-will-have-two-options","title":"2. To perform an invariable memory check, the library uses CRC (Cyclic Redundancy Check) calculations for Flash memory. If the user calculates using hardware, the user will need to initialize the GPCRC module to support the calculation. Users can also enable <code>#define SL_IEC60730_CRC_USE_SW_ENABLE</code> for software calculation. To calculate the CRC value, It will have two options:","text":"<ul> <li> <p>Start from the user's specified address and continue to the end of the Flash region.</p> </li> <li> <p>Calculate multiple regions by providing the starting and ending addresses for each one. For additional details, refer to the file <code>oem_iec60730.c</code>.</p> </li> </ul> <p>And then store the calculated CRC value in the designated end-flash variable. Currently, the <code>check_sum</code> variable is set to the end address of the user code that utilizes the IEC Library.</p> <p>In the case of the GCC toolchain, the <code>check_sum</code> variable is defined in the linker file. For the IAR toolchain, you can find it in the demo example. Right-click on the project and navigate to Properties &gt; C/C++ Build &gt; Settings &gt; IAR Linker for ARM. In the Extra Options section, you can add the option for CRC_16.</p> <pre><code>--keep check_sum --place_holder check_sum,2,.checksum,64\n</code></pre> <p>Or for CRC_32:</p> <pre><code>--keep check_sum --place_holder check_sum,4,.checksum,64\n</code></pre> <p>By default, the demo project uses option CRC_16</p> <p></p>"},{"location":"iec60730_safety_library_integration_to_sdk/#figure-21-iar-define-checksum-variable","title":"Figure 21 IAR define checksum variable","text":""},{"location":"iec60730_safety_library_integration_to_sdk/#3-configure-watchdog-test-this-configuration-determines-which-watchdog-unit-will-be-checkedthe-library-does-not-initialize-the-watchdog-units-the-user-should-do-the-initialization-we-support-configuration-for-watchdog-module","title":"3. Configure Watchdog Test: this configuration determines which watchdog unit will be checked.The library does not initialize the watchdog units, the user should do the initialization. We support configuration for watchdog module","text":""},{"location":"iec60730_safety_library_integration_to_sdk/#figure-22-configuration-for-watchdog-module","title":"Figure 22 Configuration for watchdog module","text":"<p>The two define used to enable watchdog testing are used in the application:</p> <pre><code>#define SL_IEC60730_WDOG0_ENABLE\n#define SL_IEC60730_WDOG1_ENABL\n</code></pre> <p>If these macros are not enabled, it will show an error saying watchdog checking is not enabled.</p> <ul> <li> <p>To clear reset cause flags in the RSTCASUES register after watchdog testing is completed. Enable configuration of the definition of macro <code>#define SL_IEC60730_RSTCAUSES_CLEAR_ENABLE</code>. In our demo, this feature is enabled.</p> </li> <li> <p>The static variable <code>iec60730_watchdog_count</code> must be located at a memory location that is not cleared when system startup <code>(section\".ram_no_clear\")</code>.</p> </li> <li> <p>The global variable <code>iec60730_watchdog_state</code> must be located at a memory location that is not cleared when system startup <code>(section \".ram_no_clear\")</code>. To enable saving <code>iec60730_watchdog_state</code> to backup RAM on Series 2, enable the macro <code>#define SL_IEC60730_SAVE_STAGE_ENABLE</code>. By default, it will be disabled.Define macro <code>SL_IEC60730_BURAM_IDX</code> to select which register of the BURAM will be used. The default value is <code>0x0UL</code>.</p> </li> </ul>"},{"location":"iec60730_safety_library_integration_to_sdk/#4-before-calling-the-sl_iec60730_post-functionwe-need-to-do-the-following-steps","title":"4. Before calling the <code>sl_iec60730_post</code> function,we need to do the following steps:","text":"<ul> <li> <p>Configure the clock for the timers. You can refer to these configurations in our demo examples, file <code>oem_iec60730_init_device.c</code>.</p> </li> <li> <p>Create two timers with 10 milliseconds (ms) and 100 milliseconds (ms) interrupt periods (parameters 10ms and 100ms are recommended values) to test the clock and the clock switch. You can refer our demo example, file <code>oem_iec60730_timer.c</code> for more details. Note that adjusting the 10ms and 100ms values will require adjusting other configuration <code>IEC60730_SYS_CLK</code>:</p> </li> </ul> <p></p>"},{"location":"iec60730_safety_library_integration_to_sdk/#figure-23-configuration-for-system-clock-module","title":"Figure 23 Configuration for system clock module","text":""},{"location":"iec60730_safety_library_integration_to_sdk/#5-to-perform-a-variable-memory-check-the-library-uses-marchc-and-marchxc-algorithms-it-will-have-two-options","title":"5. To perform a variable memory check, the library uses MarchC and MarchXC algorithms. It will have two options:","text":"<p>- Start from the user's specified address in RAM and continue to the end of the RAM region.</p> <p>- Calculate multiple RAM regions by providing the starting and ending addresses for each one. For additional details, refer to the file <code>oem_iec60730.c</code>.</p>"},{"location":"iec60730_safety_library_integration_to_sdk/#6-before-calling-the-sl_iec60730_bist-function-we-should-set-the-flag-for-the-sl_iec60730_program_counter_check-variable-some-of-the-following-flags-are-set-by-the-library-iec60730-iec60730_vmc_completeiec60730_imc_completeiec60730_cpu_clocks_com-pleteand-iec60730_interrupt_complete","title":"6. Before calling the <code>sl_iec60730_bist</code> function, we <code>SHOULD</code> set the flag for the <code>sl_iec60730_program_counter_check</code> variable. Some of the following flags are set by the Library IEC60730: <code>IEC60730_VMC_COMPLETE,IEC60730_IMC_COMPLETE,IEC60730_CPU_CLOCKS_COM PLETE,and IEC60730_INTERRUPT_COMPLETE</code>.","text":"<p>Other flags (IEC60730_GPIO_COMPLETE, IEC60730_ANALOG_COMPLETE,etc.) are up to you to develop additional test functions. The <code>sl_iec60730_program_counter_check</code> variable <code>SHOULD</code> set the flags corresponding to the unavailable test to ensure that the Program Counter Check is guaranteed.</p> <p>In the demo examples,you will often see the following code.</p> <pre><code>sl_iec60730_program_counter_check   |=IEC60730_GPIO_COMPLETE\n                                    | IEC60730_ANALOG_COMPLETE\n                                    | IEC60730_OEM0_COMPLETE\n                                    | IEC60730_OEM1_COMPLETE\n                                    | IEC60730_OEM2_COMPLETE\n                                    | IEC60730_OEM3_COMPLETE\n                                    | IEC60730_OEM4_COMPLETE\n                                    | IEC60730_OEM5_COMPLETE\n                                    | IEC60730_OEM6_COMPLETE\n                                    | IEC60730_OEM7_COMPLETE;\n</code></pre> <ul> <li> <p>On demo eample, executes the external communication test that sets the <code>IEC60730_COMMS_COMPLETE</code> flag by itself.</p> </li> <li> <p>The function <code>sl_iec60730_bist</code> SHOULD be called in periodical task or a supper loop while(1).</p> </li> </ul>"},{"location":"iec60730_safety_library_integration_to_sdk/#7-remember-to-increment-the-irq-counter-variable-every-time-the-interrupt-to-test-occurs-you-can-refer-to-the-oem_irq_exec_count_tick-function-in-our-demo-examples","title":"7.  Remember to increment the IRQ counter variable every time the interrupt to test occurs. You can refer to the <code>oem_irq_exec_count_tick</code> function in our demo examples.","text":"<pre><code>void TIMERO_IRQHandler(void) {\n\n...\n\noem_irq_exec_count_tick();\n\n}\n\nvoid oem_irq_exec_count_tick(void){\n\noem_irq_exec_count[0]++;\n\n}\n</code></pre>"},{"location":"iec60730_safety_library_integration_to_sdk/#8-create-the-function-sl_iec60730_safe_state-the-purpose-of-this-function-is-to-handle-when-an-error-occurs-an-example-of-handling-of-this-function-refer-files-oem_iec60730_functionsc-after-generating-our-demo-example-successfully-you-also-could-add-your-code-in-file-appc-and-apph","title":"8. Create the function <code>sl_iec60730_safe_state</code>. The purpose of this function is to handle when an error occurs. An example of handling of this function refer files <code>oem_iec60730_functions.c</code>. After generating our demo example successfully, you also <code>COULD</code> add your code in file app.c and app.h","text":""},{"location":"iec60730_safety_library_integration_to_sdk/#10-revision-history","title":"10. Revision history","text":"Revision Date Description 0.1.0 Oct 2021 Initial Revision 0.2.0 Nov 2021 Section 7: Added description for Watchdog 0.3.0 Mar 2023 Remove Section 8. 0.4.0 Apr 2023 Update document 1.0.0 Sep 2023 Section 1: Added mention aboutEFM32PG22 and EFR32xG22devices. 1.1.0 June 2024 Adding Section 3 and Section 4 for support creates a Library ExtensionUpdated other sections for suit withthe released package EFR32xG12and EFR32xG24 devices. 2.0.0 Nov 2024 Rewrite the documentation by the re-factory code of the library support device EFR32MG families."},{"location":"release_note/","title":"Release Notes","text":"<p>This release contains the following components:</p> <p>Library (source files)</p> <ul> <li> <p>/lib/asm <li> <p>/lib/config <li> <p>/lib/inc <li> <p>/lib/src <li> <p>/lib/toolchain <p>Library Dependencies (template files)</p> <ul> <li>/simplicity_sdk <p>Test (source files)</p> <ul> <li> <p>/test/unit_test <li> <p>/test/integration_test <li> <p>/test/test_script <p>Sample</p> <ul> <li>/sample <p>CMake file</p> <ul> <li> <p>/cmake <li> <p>CMakeLists.txt <p>Documentation</p> <ul> <li> <p>/docs <li> <p>mkdocs.yml <li> <p>iec60730.doxygen <p>SDK extension files</p> <ul> <li> <p>/components <li> <p>*.slce <li> <p>*.slsdk <li> <p>*.xml <p>Coding Convention</p> <ul> <li> <p>/tools <li> <p>.pre-commit-config.yaml"},{"location":"release_note/#revision-history","title":"Revision History","text":"<p>2.0.0 Release</p> <ul> <li> <p>Supported Devices: EFR32MG families (confirmed devices included: EFR32MG12, EFR32MG21, EFR32MG22, EFR32MG24)</p> </li> <li> <p>Supported Compilers: GCC, IAR</p> </li> <li> <p>Update project from make file to CMake file</p> </li> <li> <p>Rewrite the library IEC60730 code</p> </li> <li> <p>Update GSDK extension for the IEC60730 Library following the changes of the source library</p> </li> <li> <p>Support unit test, integration test</p> </li> <li> <p>Support check coding convention</p> </li> <li> <p>Support mkdocs</p> </li> </ul> <p>1.2.0 Release</p> <ul> <li> <p>Supported Devices: EFR32xG24, EFM32xG12</p> </li> <li> <p>Supported Compilers: GCC, IAR</p> </li> <li> <p>Added GSDK extension for the IEC60730 Library.</p> </li> <li> <p>Integrated demo app to the GSDK extension.</p> </li> </ul> <p>1.1.0 Release</p> <ul> <li> <p>Supported IEC60730 standard</p> </li> <li> <p>Supported Devices: EFR32xG22, EFM32PG22</p> </li> <li> <p>Supported Compilers: GCC, IAR</p> </li> </ul> <p>1.0.0 Release</p> <ul> <li> <p>Supported IEC60730 standard</p> </li> <li> <p>Supported Devices: EFR32xG21, EFR32xG23</p> </li> <li> <p>Supported Compilers: GCC, IAR</p> </li> </ul>"},{"location":"support_calculate_crc/","title":"Support calculate CRC by Srecord","text":""},{"location":"support_calculate_crc/#install","title":"Install","text":"<p>On Linux</p> <pre><code>sudo apt install srecord\n</code></pre> <p>On Window: Download Srecord to install</p>"},{"location":"support_calculate_crc/#arguments-to-bash-script","title":"Arguments to bash script","text":"<pre><code>PROJ_NAME=$1\nBUILD_DIR=$2\nSREC_PATH=$3\nTOOL_CHAINS=$4\nSTART_ADDR=$6\n</code></pre> <p>For example:</p> <pre><code>$ bash sl_iec60730_cal_crc16.sh \"${PROJ_NAME}\" \"${BUILD_DIR}\" \"C:\\srecord\\bin\" GCC \"0x8000000\"\n</code></pre> <p>Or if you want to calculate multiple regions:</p> <pre><code>$ bash sl_iec60730_cal_crc16.sh \"${PROJ_NAME}\" \"${BUILD_DIR}\" \"C:\\srecord\\bin\" GCC \"0x8000000 0x8000050 0x80000a0 0x80000f0 0x8000140 0x8000190\"\n</code></pre> <p>[!NOTE] If you calculate multiple regions CRC, you need to enter the start and end addresses of each zone. For example, in the above command, srec will calculate a three-range CRC: 0x8000000 - 0x8000050; 0x80000a0 - 0x80000f0; 0x8000140 - 0x8000190.</p> <p>Path <code>${BUILD_DIR}</code> have the files <code>*.bin</code>, <code>*.hex</code>, and <code>*.s37</code>. A <code>*.map</code> file is also needed in this directory, so that bash can check to find the address of the <code>check_sum</code> variable to store the calculated CRC value.</p>"}]}